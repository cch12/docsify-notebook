> 持续更新中

正则表达式，要么匹配字符、要么匹配位置。[查看常用正则表达式][link1]

- RegExp对象
  - 创建RegExp对象
  - RegExp对象的属性
  - RegExp对象的方法
- 正则表达式规则

## RegExp对象
### 创建RegExp对象
1、对象自面量方式，所有的元字符都需要进行转义
```
let expression1 = /pattern/flags
```
2、构造函数方式，元字符需要双重转义
```
let expression2 = new RegExp("pattern", "flags")
```
 - pattern: 模式，即任何简单或者复杂的正则表达式；
 - flags: 修饰符标志，可以多个，用来指定正则表达式的行为。

### RegExp对象的属性
一个正则表达式对象包含以下属性：
- global：默认值false，是否全局搜索
- ignoreCase：默认值false，是否忽略大小写
- multiline：默认值false，是否跨行搜索
- lastIndex：默认值0，搜索的开始索引
- source：存储正则表达式的匹配模式

除了lastIndex外，所有的属性，在创建对象之后，不可再修改。

其中前三个属性，为正则表达式修饰符，分别对应：`g`、`i`、`m`，修饰符无序。

### RegExp对象的方法
**查找匹配内容的两个方法：**
- exec()：返回第一个匹配项信息的数组，没有匹配的情况下返回null。
- test()：返回布尔值，模式与字符串参数匹配时，返回true，否则false。

注意：对于exec()方法，当设置了全局标识时，对同一个字符串，每次调用exec()函数都会在字符串中继续查找新匹配项目。返回的数组还包含两个额外的属性：index和input，index表示匹配想在字符串中的位置，input表示应用正则表达式的字符串。

**以正则表达式为参数的方法：**
String对象中可以使用`IndexOf()`和`lastIndexOf()`方法搜索文本。

String对象提供以正则表达式对象作为参数的方法以实现高级文本搜索：
- match()：返回第一个匹配项信息的数组，本质上与exac()用法一样。
- search()：返回字符串中第一个匹配项的索引，如果没找到则返回-1。
- replace()：接受两个参数，第一个是正则或者字符串，第二个参数是字符串或者函数
- split()：根据指定的正则表达式将目标字符串分割成若干个数组元素

## 正则表达式规则
### 字符匹配
#### 1、量词
`{m,n}`，表示连续出现最少m次，最多n次，注意`,`前后不能存在空格。一般在不确定重复次数时使用。
```
let str = 'abc abbc abbbc acb accb abbbbc'
let regex = /ab{2,3}c/g
console.log(str.match(regex))
// => abbc abbbc
```

- 贪婪匹配：尽可能多的匹配，默认位贪婪匹配
- 惰性匹配：尽可能少的匹配，在量词后面增加`?`可实现惰性匹配，当前面的条件满足时，就不再继续尝试了。

惰性量词|贪婪量词 | 具体含义
------|-------|-----
`{m,n}？`|`{m,n}`|表示出现m-n次
`{m,}？`|`{m,}`|表示至少出现m次
`{m}?`|`{m}`|表示出现m次
`??`|`?`|`{0, 1}`，表示出现1次或者不出现
`+?`|`+`|`{1,}`，表示至少出现一次
`*?`|`*`|`{0,}`，表示出现任意次

```
var regex = /\d{2,5}/g
var regex1 = /\d{2,5}?/g
var string = '1 1234 12345 123456'
console.log('贪婪模式---：', string.match(regex))
// => 贪婪模式---： ["1234", "12345", "12345"]
console.log('惰性模式---：', string.match(regex1))
// => 惰性模式---： ["12", "34", "12", "34", "12", "34", "56"]
```


#### 2、字符组
1）**常见字符组**

`[]`，如：`[abc]`，表示该字符可以是a b c中的任意一个。一般在不确定某个字符时使用。
```
let str = 'abc acc adc aac afc'
let regex = /a[ac]c/g
console.log(str.match(regex))
// => acc aac
```
- 字符组可使用 **范围表示法** 来表示连续的多个字符，使用`-`来省略和简写。如`[1-6a-z]`，表示1到6的所有数字以及a到z的所有字母。
- 因为连字符的特殊用途，在匹配`a` `-` `z`这三者中的任一字符时，使用`-az`或者`az-`或者`a\-z`等形式代替`a-z`的形式

2）**取反字符组**

反义字符组，即排除某些字符，如`[^abc]`，表示一个除`a` `b` `c`之外的任意一个字符。

3）字符组常见符号

字符组 | 具体含义
------|-------
`\d`|`[0-9]`，表示1位数字
`\D`|`[^0-9]`，表示除数字外的任意字符
`\w`|`[0-9a-zA-Z_]`，表示数字、大小写字母以及下划线
`\W`|`[^0-9a-zA-Z_]`，表示除数字、大小写字母以及下划线外的任意字符
`\s`|`[\t\v\n\r\f]`，表示空白符，包括：空格、水平制表符、垂直制表符、换行符、回车符、换页符。
`\S`|`[^\t\v\n\r\f]`，表示非空白符
`.`|`[^\n\r\u2028\u2029]`，表示通配符，除换行符、回车符、行分割符和段分割符外任意字符
- 如需要匹配所有字符，可使用`[\d\D]`，`[\w\W]`，`[\s\S]`, `[^]`中的任意一个

#### 3、分支
`(p1|p2|p3)`，其中`p1` `p2` `p3`为子模式，使用管道符`|`分隔，表示其中任何之一。

**注意**：分支结构为惰性的，即当前面匹配成功，后面不会继续尝试。

### 位置匹配
位置(锚)为相邻字符之间的位置。

比如（在`hello`开头和结尾增加`#`）：
```
let str = 'hello'
str = str.replace(/^|$/g, '#')
console.log(str)
// => #hello#
```
#### 1、锚

锚     | 具体含义
---------|-------
`^`| 脱字符，匹配开头，在多行匹配中，匹配行开头
`$`| 美元符号，匹配结果，在多行匹配中匹配行结尾
`\b`|单词边界，也就是`\w`和`\W`之间的位置，也包括 \w 与 ^ 之间的位置，和 \w 与 $ 之间的位置
`\B`|非单词边界，与`\b`相反
`(?=P)`|`[\t\v\n\r\f]`，表示空白符，包括：空格、水平制表符、垂直制表符、换行符、回车符、换页符。
`(?!P)`|`[^\t\v\n\r\f]`，表示非空白符

如：多行匹配模式下，行首增加`#`
```
let str = 'I\nlove\njavascript'
str = str.replace(/^/gm, '# ')
console.log(str)
// => # I
// => # love
// => # javascript
```

[link1]: https://github.com/junruchen/junruchen.github.io/blob/master/dailyPractice/match.js